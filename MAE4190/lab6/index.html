<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
        Lab 6
    </title><link href="https://TrevorDales.github.io/ atom.xml" title="Trevor Dales" rel=alternate type=application/atom+xml><link href=https://TrevorDales.github.io/main.css media=screen rel=stylesheet><meta content="Hi! My name is Trevor." name=description><meta content="Hi! My name is Trevor." name=description><meta content="index, nofollow" name=robots><meta content="Trevor Dales" property=og:title><meta content=article property=og:type><meta content=https://TrevorDales.github.io/MAE4190/lab6/ property=og:url><meta content="Hi! My name is Trevor." property=og:description><meta content="Trevor Dales" property=og:site_name><meta content="default-src 'self' ws://127.0.0.1:1024/; img-src 'self' https://*; script-src 'self'; style-src 'self'; font-src 'self'; frame-src https://www.youtube.com https://player.vimeo.com;" http-equiv=Content-Security-Policy><body><header><div class=navbar><div class="nav-title nav-navs"><a class="nav-links home-title" href=https://TrevorDales.github.io>Trevor Dales</a></div><nav class="nav-title nav-navs"><a class=nav-links href=/MAE4190> <img 4190 alt=MAE height=15 src=/menu_icon/projects.png width=15> MAE 4190</a><a class=nav-links href=/contact/contact> <img alt=Contact height=15 src=/menu_icon/resume.png width=15> Contact</a></nav><nav class="socials nav-navs"><label class=theme-switcher for=themeswitch><div class=background></div> <input id=themeswitch type=checkbox> <div class=switch><img alt="theme switch to dark" class=moon src=/menu_icon/moon.png><img alt="theme switch to light" class=sun src=/menu_icon/sun.png></div></label></nav></div></header><div class=content><main><article><div class=title><h2>Lab 6</h2><div class=meta>Posted on <time>2025-03-19</time></div></div><section class=body><h1 id=code-structure>Code Structure</h1><p>Similarily to the last lab, I began by structuring the information flow of the system to enable quick debugging and tuning:<ul><li><p>Functions were created on the Artemis for controlling the motors and collecting sensor data, allowing them to be called as needed.</p><li><p>A BLE command initiates the PID-controlled motion, which runs for 10 seconds while sensor and PID data arrays are populated.</p><li><p>Additional BLE commands transfer the recorded data from the Artemis to my laptop for plotting and analysis.</p></ul><p>I made sure to define variables that change often as global variables in my artemis code. This way, I could define them in python before sending them over BLE, allowing me to change their values without reuploading to the artemis.<pre class=z-code><code><span class="z-text z-plain">ble.send_command(CMD.START_YPID, f"{kp}|{ki}|{kd}|{target_angle}|{df_alpha}|{turn_floor}")
</span></code></pre><br><br><h1 id=sensor-data>Sensor data</h1><p>Given the drift correction and high sampling rate of the DMP built into the IMU, I decided to run my controller on this data. I followed Stephan Wagner's tutorial, and refactored his example code in a way that fit my BLE code structure. I defined a function that would get new yaw data and save it in a global array, and called this continually from my PID logic loop. This sensor runs faster than 1kHz, and can handle angular speed above 2000 degrees per second - this is way more than anything I expect to need for my controller.</p><br><br><h1 id=sending-turn-commands>Sending turn commands</h1><p>My turn function takes a control input and uses it to execute a turn. It uses a calibration factor to account for the slightly mismatched motors. <br> <br><p>Something that I improved on from last lab was the way I mapped the control signal to a speed. Rather than mapping my control value to be in the range 0-255 and then pulling up any low values to a floor, I just mapped my control input straight to the range of values above my motor deadband. This means that my proportional input is now more nuanced than just an on/off input.<pre class=z-code><code><span class="z-text z-plain">turn(int speed)
</span><span class="z-text z-plain">{
</span><span class="z-text z-plain">// Speed input is a percentage out of 100%. Positive numbers go right, negative go left. 0 stops the car.
</span><span class="z-text z-plain">speed = constrain(speed, -100, 100);
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">if (speed > 0)  
</span><span class="z-text z-plain">    {
</span><span class="z-text z-plain">    // turn right
</span><span class="z-text z-plain">    speed = map(speed, 0, 100, turn_floor, 255); //map percentage to pwm range (floor-255)
</span><span class="z-text z-plain">    int cspeed = speed * tc;  
</span><span class="z-text z-plain">    analogWrite(FORWARD_RIGHT,0); 
</span><span class="z-text z-plain">    analogWrite(FORWARD_LEFT,speed);
</span><span class="z-text z-plain">    analogWrite(BACKWARD_RIGHT,cspeed); 
</span><span class="z-text z-plain">    analogWrite(BACKWARD_LEFT,0);  
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">if (speed < 0)  
</span><span class="z-text z-plain">    {
</span><span class="z-text z-plain">    // turn left
</span><span class="z-text z-plain">    speed = -1 * speed;
</span><span class="z-text z-plain">    speed = map(speed, 0, 100, turn_floor, 255); 
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    etc...
</span></code></pre><p>To clarify, the result of this is that my control input is a percentage, where 1% corresponds to the lowest value that will still spin the car, and 100% is the highest speed the car can spin.</p><br><br><h1 id=proportional-control>Proportional Control</h1><p>With the infrastructure established, I started with a P controller. The DMP yaw data is already within range [-180, 180], so I just had to normalize my error to ensure I was turning in the direction closer to the target:<pre class=z-code><code><span class="z-text z-plain">float error = current_yaw - target;
</span><span class="z-text z-plain">    while (error > 180) error -= 360;
</span><span class="z-text z-plain">    while (error < -180) error += 360;
</span></code></pre><br><p>Then, calculating the proportional term was a simple product:<pre class=z-code><code><span class="z-text z-plain">    ypid_p[ypidCounter] = kp * e;
</span></code></pre><br><br> The result was a controller that worked, but there were some issues. <br><br><div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/X-KvWyYE8B0 width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe><img src=/Lab6/pcontrol.png style=display:block><h5></h5></div><p>For one, the overshoot was massive - enough to send the robot in a full circle sometimes. Decreasing Kp kind of helped, but decreasing it too much meant the robot wouldn't move at all. Also, the steady state error got worse with a smaller Kp. This specific result was tuned to Kp = 0.3, and both problems are visible here. Something odd was that the behavior seemed better when responding to disturbance (in the latter half of this graph, for example) - more on that later. <br> <br><h1 id=proportional-derivative-control>Proportional-Derivative Control</h1><p>At this point, I decided to add a derivative term to my controller to help manage the comical overshoot. I also added a low pass filter to this term to help deal with the large amount of noise I saw when I first implemented it.<pre class=z-code><code><span class="z-text z-plain">unsigned long current_time = millis();
</span><span class="z-text z-plain">float dt = (current_time - yprev_time) / 1000.0; // Convert to seconds
</span><span class="z-text z-plain">if (dt <= 0) {
</span><span class="z-text z-plain">    dt = 0.001; // Prevent division by zero
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">float d_raw = kd * (e - yprev_error) / dt;  // Compute raw derivative
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">yfiltered_d = (1 - df_alpha) * yfiltered_d + (df_alpha) * d_raw;  // Apply low-pass filter
</span><span class="z-text z-plain">ypid_d[ypidCounter] = d_raw;  // Log raw derivative
</span><span class="z-text z-plain">ypid_df[ypidCounter] = yfiltered_d;  // log filtered derivative
</span></code></pre><div align=center><img src=/Lab6/pdcontrol.png style=display:block><h5 id=kp-3-kd-3>Kp = 3, Kd = 3</h5></div><p>Honestly, this didn't really fix my overshoot issues. No matter how high I cranked up Kd, my car was still overshooting. I spent so many hours trying to tune this in different ways to fix the issue - I tried lowering Kp, lowering my motor input floor, adjusting Kd, adjusting alpha for the derivative lpf - nothing seemed to be working. All of my debugging showed expected values of my terms.</p><br><p>Finally, I starting paying more attention to the fact that this overshoot only happened on the first turn. I realised that in response to a disturbance, the controller worked fine. I had many theories about why this was happening, but I finally tried something that worked: holding a sustained motor input before executing the first turn. I'm not totally sure what's happening here, but it's clear that the motor is unpredictable and less responsive in the moments after it first receives current. The solution is literally as simple as manually overriding the controller in order to send a small speed value for the first two seconds:<pre class=z-code><code><span class="z-text z-plain">if (time_passed < 2000){
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    ycontrol_input = 1; // 1% input won't cause any turning
</span><span class="z-text z-plain">}
</span></code></pre><p>And the result is a remarkably improved response. Even with just a P controller, after this fix I was able to get great results. I cranked Kp up for faster response and less steady state error.<div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/35uW_snftZQ width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe><img src=/Lab6/pdfixed.png style=display:block><h5 id=kp-6-you-can-hear-the-rev-up-the-motors-do-before-starting-active-control>Kp = 6. You can hear the 'rev up' the motors do before starting active control.</h5></div><br><br><p>After this realization I added my derivative term back. I adjusted alpha to make the term very noise resistant, and I was able to tune Kd to reduce the overshoot further while maintaining the quick response. I also added an error tolerance that would allow the car to stop the motors when it was close to its target; this reduced rapid oscillations near the setpoint.<pre class=z-code><code><span class="z-text z-plain">if ( abs(e) < 3 ) {
</span><span class="z-text z-plain">    ycontrol_input = 0;
</span><span class="z-text z-plain">    turn(ycontrol_input);
</span><span class="z-text z-plain">} else {
</span><span class="z-text z-plain">    turn(ycontrol_input);
</span><span class="z-text z-plain">}
</span></code></pre><div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/v422ka4v5X8 width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe><img src=/Lab6/pdtuned.png style=display:block><h5 id=kp-6-kd-0-25-alpha-0-01-overshoot-decreased-even-further>Kp = 6, Kd = 0.25, alpha = 0.01. Overshoot decreased even further!</h5></div><br><p>At this point I am pretty happy with my controller. I don't see a need to add an integral term, as my high Kp term already leads to a small steady state error. Overshoot would normally be a concern with a high Kp, but since the car can change direction rapidly, it remains negligible and self-correcting (derivative term also helps reduce overshoot). Derivative kick is also not a huge issue for me, as the lpf on the derivative term keeps it from affecting the system too much. My biggest worry moving forward would be if I need to initiate a turn in a situation where I can't sit still and 'charge up' the motors for two seconds. This is something I will investigate in the future.</p><br><h1 id=collaboration>Collaboration</h1><p>I worked with Jack Long and Lucca Correia extensively. I also referenced Stephan Wagner's tutorial for DMP data collection. Lastly, ChatGPT helped me make pretty plots.</section></article></main></div><footer><section><nav><a class="nav-links social" rel="noopener noreferrer" href=https://github.com/TrevorDales target=_blank> <img alt=github src=/social_icons/github.svg title=github> </a></nav><nav><span classname=desktop-only>This blog is powered by <a rel="noopener noreferrer" href=https://getzola.org/ target=_blank>Zola</a> with theme by <a rel="noopener noreferrer" href=https://syedzayyan.com/ target=_blank>SZM</a></span></nav></section><script src=https://TrevorDales.github.io/js/main.js></script></footer>