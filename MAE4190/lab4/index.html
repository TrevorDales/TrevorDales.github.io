<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
        Lab 4
    </title><link href="https://TrevorDales.github.io/ atom.xml" title="Trevor Dales" rel=alternate type=application/atom+xml><link href=https://TrevorDales.github.io/main.css media=screen rel=stylesheet><meta content="Hi! My name is Trevor." name=description><meta content="Hi! My name is Trevor." name=description><meta content="index, nofollow" name=robots><meta content="Trevor Dales" property=og:title><meta content=article property=og:type><meta content=https://TrevorDales.github.io/MAE4190/lab4/ property=og:url><meta content="Hi! My name is Trevor." property=og:description><meta content="Trevor Dales" property=og:site_name><meta content="default-src 'self' ws://127.0.0.1:1024/; img-src 'self' https://*; script-src 'self'; style-src 'self'; font-src 'self'; frame-src https://www.youtube.com https://player.vimeo.com;" http-equiv=Content-Security-Policy><body><header><div class=navbar><div class="nav-title nav-navs"><a class="nav-links home-title" href=https://TrevorDales.github.io>Trevor Dales</a></div><nav class="nav-title nav-navs"><a class=nav-links href=/MAE4190> <img 4190 alt=MAE height=15 src=/menu_icon/projects.png width=15> MAE 4190</a><a class=nav-links href=/contact/contact> <img alt=Contact height=15 src=/menu_icon/resume.png width=15> Contact</a></nav><nav class="socials nav-navs"><label class=theme-switcher for=themeswitch><div class=background></div> <input id=themeswitch type=checkbox> <div class=switch><img alt="theme switch to dark" class=moon src=/menu_icon/moon.png><img alt="theme switch to light" class=sun src=/menu_icon/sun.png></div></label></nav></div></header><div class=content><main><article><div class=title><h2>Lab 4</h2><div class=meta>Posted on <time>2025-03-04</time></div></div><section class=body><br><h1 id=wiring-the-motor-drivers>Wiring the motor drivers</h1><p>To send signals to my motor drivers, I decided to use pins 13, A14, A15, and A16 on the Artemis board. While their proximity can increase the risk of a short, their location allows for compact wiring. Additionally, each pin is able to send PWM signals, as indicated by the (~) symbol on the Artemis data sheet.</p><br><div align=center><img src=/Lab4/wiringlab4.png style=display:block><h5 id=wiring-schematic>Wiring schematic</h5><br></div><br><p>Using two separate batteries protects the Artemis from voltage spikes caused by the inductive load of the motors. Without this, powering off the motors while they are turning could damage the board or other sensors in the circuit.</p><br><h1 id=oscilloscope-testing>Oscilloscope testing</h1><p>Before mounting anything to my car, I tested the signal coming out of the driver with an oscilloscope. This allowed me to sanity check my wiring and get any debugging out of the way before making any changes permanent. To achieve this, I used a power supply set to 3.7V to simulate the 3.7V that the 850mAh battery will be providing to the driver. I then hooked up the output wires of the driver to a scope, allowing me to see the voltage that will be provided to the motors.</p><br><div align=center><img src=/Lab4/driverwired.png style=display:block><h5 id=motor-driver-and-connections-for-testing>Motor driver and connections for testing</h5><br></div><br><p>To send a PWM signal to my driver, I used a basic analogWrite() command from the Artemis:<pre class=z-code><code><span class="z-text z-plain">#define AB1IN_LEFT 16
</span><span class="z-text z-plain">#define AB2IN_LEFT 15
</span><span class="z-text z-plain">void setup() {
</span><span class="z-text z-plain">    pinMode(AB1IN_LEFT,OUTPUT);
</span><span class="z-text z-plain">    pinMode(AB2IN_LEFT,OUTPUT);
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">void loop() {
</span><span class="z-text z-plain">    analogWrite(AB1IN_LEFT,100);
</span><span class="z-text z-plain">    analogWrite(AB2IN_LEFT,0);
</span><span class="z-text z-plain">}
</span></code></pre><br><p>The result was a clear PWM signal that matches the ~40% (100/255) duty cycle that the Artemis was sending to the driver:<div align=center><img src=/Lab4/scope.png style=display:block><h5 id=scope-result>Scope result</h5><br></div><br><p>Now that I had verified my driver performs as expected, I replaced the scope probes with the power and ground wires on my robot's motors. She spins!<div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/Pvlj4yAtwwE width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe></div><br><p>Next, I replaced the power supply with my 850mAh battery. I also flashed new code that tested both directions of rotation.<div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/NES6Lw8goOs width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe></div><br><p>With all the components working as expected, I next mounted components on my car. I used zipties for this primarily, as they are a more rugged fastener than tape, yet are still easy to remove. I poked holes in the plastic housing and was also often able to mount using holes already present on the sensors.<div align=center><img src=/Lab4/carbefore.png style=display:block><h5 id=before-stock-electronics>Before (stock electronics)</h5><br><br><img src=/Lab4/carlabel.png style=display:block><h5 id=after>After!</h5><br><br></div><div align=center><img src=/Lab4/carcinematic.png style=display:block><br></div><br><br><p>After mounting the electronics, I took the robot for a test drive:<div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/sMSqqblPs5U width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe></div><p>The car drives, but there is some drift due to imbalance between the motors. I implemented a calibration factor to throttle the stronger motor - this is a multiplicative factor rather than an additive constant, because the imbalance seemed to become worse at higher frequency PWM signals. I also chose a factor that reduced the stronger motor rather than increasing the weaker one, because I didn't want the weaker motor saturating at 255 before the other one. At this point, I also took the time to define pins and variables in ways that made sense for easy editing down the line.</p><br><pre class=z-code><code><span class="z-text z-plain">#define FORWARD_RIGHT 16
</span><span class="z-text z-plain">#define BACKWARD_RIGHT 15
</span><span class="z-text z-plain">#define BACKWARD_LEFT 14
</span><span class="z-text z-plain">#define FORWARD_LEFT 13
</span></code></pre><br><pre class=z-code><code><span class="z-text z-plain">float c = 0.6; // Calibration factor
</span><span class="z-text z-plain">int speed = 200;
</span><span class="z-text z-plain">int cspeed = speed * c; // Corrected speed
</span></code></pre><br><pre class=z-code><code><span class="z-text z-plain">void loop() {
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">// go forward
</span><span class="z-text z-plain">analogWrite(FORWARD_RIGHT,cspeed); 
</span><span class="z-text z-plain">analogWrite(FORWARD_LEFT,speed);
</span><span class="z-text z-plain">analogWrite(BACKWARD_RIGHT,0); 
</span><span class="z-text z-plain">analogWrite(BACKWARD_LEFT,0);
</span><span class="z-text z-plain">delay(1300);
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">//stay still
</span><span class="z-text z-plain">analogWrite(FORWARD_RIGHT,0); 
</span><span class="z-text z-plain">analogWrite(FORWARD_LEFT,0);
</span><span class="z-text z-plain">analogWrite(BACKWARD_RIGHT,0); 
</span><span class="z-text z-plain">analogWrite(BACKWARD_LEFT,0);
</span><span class="z-text z-plain">delay(2000);
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">}
</span></code></pre><br><p>This calibration factor helped the car drive straight while the motors were active, but I faced another issue with alignment. After I sent a stop command, the fact that the motors were spinning freely at different speeds would cause a turn at the end of any motion. This meant the car would drive stright until the signal ended, at which point it would spin out a little at the end of the motion. I was able to find a sort of sweet spot for my calibration factor that maximized straight active driving while minimizing the speed differential that caused this fishtail, but it isn't perfect (works best at slow speeds). In the future, I am planning to implement a ramp down for the motors, reducing the speed differential at the end of a motion.<div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/0eKnJqh2YiY width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe><h5 id=calibrated-straight-line-test>Calibrated straight line test</h5></div><br><br><p>To test the minimum PWM value required to get the car to start moving, I incrementally lowered the duty cycle until the car couldn't get going. I found this PWM value to be around 30 (~12%) for my system. Although this value is when the robot truly stops moving, steady motion only occurs above around 50 (~12%). Note that these numbers decrease pretty quickly as the battery discharges.</p><br><p>Lastly, I implemented turning. Turning the wheels on each side in opposite directions causes a torque on the car; however, the two axels do not want to rotate around the same point, so the wheels must slide on the ground in order to execute a turn. For this reason, a higher PWM value is needed to initiate turning motion rather than linear motion. I found that the minimum PWM value required to start a turn was 125 (~50%). Additionally, I used the calibration factor here as well to account for the motor imbalance.<pre class=z-code><code><span class="z-text z-plain">// Right Turn
</span><span class="z-text z-plain">analogWrite(FORWARD_RIGHT,0); 
</span><span class="z-text z-plain">analogWrite(FORWARD_LEFT,speed);
</span><span class="z-text z-plain">analogWrite(BACKWARD_RIGHT,cspeed); 
</span><span class="z-text z-plain">analogWrite(BACKWARD_LEFT,0);
</span><span class="z-text z-plain">delay(2000);
</span></code></pre><div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/72SrB49cMXc width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe></div><div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/BnnnpfU2r4M width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe><h5 id=turning-and-open-loop-control>Turning and open loop control</h5></div><br><br><h1 id=collaboration>Collaboration</h1><p>I worked with Jack Long and Lucca Correia extensively. I also referenced Wenyi's website from last year for wiring help.</section></article></main></div><footer><section><nav><a class="nav-links social" rel="noopener noreferrer" href=https://github.com/TrevorDales target=_blank> <img alt=github src=/social_icons/github.svg title=github> </a></nav><nav><span classname=desktop-only>This blog is powered by <a rel="noopener noreferrer" href=https://getzola.org/ target=_blank>Zola</a> with theme by <a rel="noopener noreferrer" href=https://syedzayyan.com/ target=_blank>SZM</a></span></nav></section><script src=https://TrevorDales.github.io/js/main.js></script></footer>