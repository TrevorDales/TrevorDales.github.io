<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
        Lab 2: Inertial Measurement Unit
    </title><link href="https://TrevorDales.github.io/ atom.xml" title="Trevor Dales" rel=alternate type=application/atom+xml><link href=https://TrevorDales.github.io/main.css media=screen rel=stylesheet><meta content="Hi! My name is Trevor." name=description><meta content="Hi! My name is Trevor." name=description><meta content="index, nofollow" name=robots><meta content="Trevor Dales" property=og:title><meta content=article property=og:type><meta content=https://TrevorDales.github.io/MAE4190/lab2/ property=og:url><meta content="Hi! My name is Trevor." property=og:description><meta content="Trevor Dales" property=og:site_name><meta content="default-src 'self' ws://127.0.0.1:1024/; img-src 'self' https://*; script-src 'self'; style-src 'self'; font-src 'self'; frame-src https://www.youtube.com https://player.vimeo.com;" http-equiv=Content-Security-Policy><body><header><div class=navbar><div class="nav-title nav-navs"><a class="nav-links home-title" href=https://TrevorDales.github.io>Trevor Dales</a></div><nav class="nav-title nav-navs"><a class=nav-links href=/MAE4190> <img 4190 alt=MAE height=15 src=/menu_icon/projects.png width=15> MAE 4190</a><a class=nav-links href=/contact/contact> <img alt=Contact height=15 src=/menu_icon/resume.png width=15> Contact</a></nav><nav class="socials nav-navs"><label class=theme-switcher for=themeswitch><div class=background></div> <input id=themeswitch type=checkbox> <div class=switch><img alt="theme switch to dark" class=moon src=/menu_icon/moon.png><img alt="theme switch to light" class=sun src=/menu_icon/sun.png></div></label></nav></div></header><div class=content><main><article><div class=title><h2>Lab 2: Inertial Measurement Unit</h2><div class=meta>Posted on <time>2025-02-11</time></div></div><section class=body><br><h1 id=setting-up-the-imu>Setting up the IMU</h1><p>I began by connecting the IMU to the Artemis. After flashing the example code, I was able to display real time values from the accelerometer.I set AD0_VAL to 1 to define the I2C address of the IMU. In this case, without soldering any connections the board maintains the default address of 0x12.<div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/8gO9bUrKclw width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe></div><br><br> Next, I checked the calibration of the sensor. The values seemed to be quite consistent, so I don't think a two-point calibration is neccessary. <br><br><img alt="Rising Temperature Graph" src=/Lab2/pitchcal.png style=display:block><div align=center><h5 id=pitch-calibration-measured-at-0-90-and-90-degrees>Pitch Calibration (measured at 0, 90, and -90 degrees)</h5><br><img alt="Rising Temperature Graph" src=/Lab2/rollcal.png style=display:block><h5 id=roll-calibration-measured-at-0-90-and-90-degrees>Roll Calibration (measured at 0, 90, and -90 degrees)</h5></div><br><br><h1 id=accelerometer-data>Accelerometer Data</h1><p>I used the following code to calculate pitch and roll from accelerometer values:<pre class=z-code><code><span class="z-text z-plain">if(myICM.dataReady())
</span><span class="z-text z-plain">    {
</span><span class="z-text z-plain">    myICM.getAGMT();
</span><span class="z-text z-plain">    currentMillis = millis();
</span><span class="z-text z-plain">    time_stamps[i] = currentMillis;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    //accel pitch  
</span><span class="z-text z-plain">    pitch_a = atan2(myICM.accY(),myICM.accZ())*180/M_PI; 
</span><span class="z-text z-plain">    pitch_a_array[i] = pitch_a;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    //accel roll  
</span><span class="z-text z-plain">    roll_a = atan2(myICM.accX(),myICM.accZ())*180/M_PI;
</span><span class="z-text z-plain">    roll_a_array[i] = roll_a;
</span><span class="z-text z-plain">    }
</span></code></pre><p>I then appended the values to the string GAAT characteristic, utlilizing a notification handler to record the values in an array for plotting. <br> <br></p><img alt="Rising Temperature Graph" src=/Lab2/pitchstatic.png style=display:block><div align=center><h5 id=plotted-pitch-data-static-noise>Plotted Pitch Data (static noise)</h5></div><br><p>The data looked very noisy on all axes. To address this, I took a fourier transform of the data to better understand the frequency spectrum that contained the noise. <br> <br></p><img alt="Rising Temperature Graph" src=/Lab2/pitchfourier.png style=display:block><br><br><p>In the frequency domain, most of the notable spikes appear between 0-5Hz. As such, I chose 5Hz as my cutoff frequency. I also calculated my data rate to be 129 messages/sec. With these numbers and the equations below, I calculated an alpha value of 0.15 for a low pass filter.<p>This number is important - too high and you will be removing information with your filter. However, too low will be ineffective for removing noise.</p><br><br><img alt="Rising Temperature Graph" src=/Lab2/equation.png style=display:block><div align=center><h5 id=where-f-c-is-cutoff-frequency-and-t-is-1-sampling-rate>Where f_c is cutoff frequency and T is 1/sampling rate.</h5></div><br><p>Using this calculated alpha value, I implemented a low pass filter for pitch and roll.</p><br><pre class=z-code><code><span class="z-text z-plain">//accel pitch low pass filter
</span><span class="z-text z-plain">lpf_pitch_a_array[i] = alpha * pitch_a + (1 - alpha) * lpf_pitch_a_array[i - 1];
</span><span class="z-text z-plain">lpf_pitch_a_array[i - 1] = lpf_pitch_a_array[i];
</span></code></pre><br><p>The resulting signal is less susceptible to noise!</p><br><br><img alt="Rising Temperature Graph" src=/Lab2/lpfstatic.png style=display:block><div align=center><h5 id=lpf-static-noise>LPF, static noise</h5></div><br><br><img alt="Rising Temperature Graph" src=/Lab2/lpfslowcircle.png style=display:block><div align=center><h5 id=lpf-isolated-circle-motion>LPF, isolated circle motion</h5></div><br><br><img alt="Rising Temperature Graph" src=/Lab2/lfpfullcircle.png style=display:block><div align=center><h5 id=lpf-full-circle-motion-the-raw-signal-is-incredibly-noisy-but-the-filter-does-a-pretty-good-job-at-capturing-the-macro-motion-of-the-sensor>LPF, full circle motion. The raw signal is incredibly noisy, but the filter does a pretty good job at capturing the macro motion of the sensor.</h5></div><br><h1 id=gyroscope-data>Gyroscope Data</h1><p>Next, I implemented data collection for the gyro sensor. Note that the X and Y axes had to be flipped to match the orientation of the gyro and accel sensors on the board.<pre class=z-code><code><span class="z-text z-plain">//gyro pitch, roll, yaw  
</span><span class="z-text z-plain">dt = (millis()-lastT)/1000.;
</span><span class="z-text z-plain">lastT = millis();
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">pitch_g_array[i] = pitch_g_array[i-1] + myICM.gyrX()*dt;
</span><span class="z-text z-plain">roll_g_array[i] = roll_g_array[i-1] - myICM.gyrY()*dt;
</span><span class="z-text z-plain">yaw_g_array[i] = yaw_g_array[i-1] + myICM.gyrZ()*dt;
</span></code></pre><br><img alt="Rising Temperature Graph" src=/Lab2/gryodata.png style=display:block><div align=center><h5 id=gryo-data-compared-to-accelerometer-while-the-noise-isn-t-as-bad-there-is-drift-due-to-integrating-error-over-time-the-accelerometer-also-seems-to-introduce-lots-of-noise-in-an-axis-when-measuring-an-acceleration-in-a-different-direction-the-gyro-is-better-at-isolating-measurements>Gryo data compared to accelerometer. While the noise isn't as bad, there is drift due to integrating error over time. The accelerometer also seems to introduce lots of noise in an axis when measuring an acceleration in a different direction - the gyro is better at isolating measurements.</h5></div><br><p>To deal with the drift, I implemented a complementary filter that used both sensors to achieve a more accurate measurement. I used the same alpha value from before, biasing the data towards the smooth gyro measurements.<pre class=z-code><code><span class="z-text z-plain">//gyo complementary filter
</span><span class="z-text z-plain">comp_pitch_g_array[i] = ( comp_pitch_g_array[i-1] + myICM.gyrX()*dt ) * (1 - alpha) + (alpha*lpf_pitch_a_array[i]);
</span><span class="z-text z-plain">comp_roll_g_array[i] = ( comp_roll_g_array[i-1] - myICM.gyrY()*dt ) * (1 - alpha) + (alpha*lpf_roll_a_array[i]);
</span></code></pre><br><img alt="Rising Temperature Graph" src=/Lab2/compfilter.png style=display:block><div align=center><h5 id=comparing-signals-for-a-slow-rotation-note-the-lack-of-drift-in-the-complementary-signal>Comparing signals for a slow rotation. Note the lack of drift in the complementary signal.</h5></div><br><br><img alt="Rising Temperature Graph" src=/Lab2/compfilter2.png style=display:block><div align=center><h5 id=sensor-data-in-response-to-sudden-vibrations-the-complementary-signal-doesn-t-drift-like-the-gryo-data-and-is-also-a-bit-less-susceptible-to-vibration-when-compared-to-the-accelerometer-data-in-many-ways-this-filter-retains-the-best-characteristics-of-each-sensor>Sensor data in response to sudden vibrations. The complementary signal doesn't drift like the gryo data, and is also a bit less susceptible to vibration when compared to the accelerometer data. In many ways, this filter retains the best characteristics of each sensor.</h5></div><br><h1 id=data-sampling>Data Sampling</h1><p>After removing all print statements, I was able to get up to around 130 messages/sec. I used floats for all of the data, as the decimal value made sense for the type of data I was collecting. I didn't use doubles because they take up more space than a float, and I didn't need the extra precision. I used 10 arrays in total - 1 time array, 4 accelerometer data arrays (including filtered data), and 5 gyroscope data arrays. Consolidating this data into less arrays might be more memory efficient, but I found that splitting the data up this way made the parsing further down the line much more organized and readable.<p>With this setup, I was able to achieve 17 seconds of data by making each array 5000 data points long. I was able to increase this length all the way to 8000 before reaching memory problems, implying a max data collection time of almost 30 seconds.</p><br><br><img alt="Rising Temperature Graph" src=/Lab2/17s.png style=display:block><div align=center><h5 id=17-seconds-of-data>17 seconds of data.</h5></div><br><h1 id=car-stunt>Car Stunt</h1><p>This week, we received our cars! I was able to get it to flip by quickly decelerating the car. One thing to note is the absolute lack of fine control.<div align=center><iframe <pre class=z-code height=315 src=https://www.youtube.com/embed/aTJ3zBcDTDw width=175><code><span class="z-text z-plain">allowfullscreen> </span></code></iframe></div><br><h1 id=collaboration>Collaboration</h1><p>I worked with Jack Long and Lucca Correia extensively. I also referenced both Daria's website and Nila's website from last year for help implementing some of the filters. Lastly, I utilized ChatGPT for lots of error debugging, and also to speed up writing plotting syntax.</section></article></main></div><footer><section><nav><a class="nav-links social" rel="noopener noreferrer" href=https://github.com/TrevorDales target=_blank> <img alt=github src=/social_icons/github.svg title=github> </a></nav><nav><span classname=desktop-only>This blog is powered by <a rel="noopener noreferrer" href=https://getzola.org/ target=_blank>Zola</a> with theme by <a rel="noopener noreferrer" href=https://syedzayyan.com/ target=_blank>SZM</a></span></nav></section><script src=https://TrevorDales.github.io/js/main.js></script></footer>